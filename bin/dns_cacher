#!/bin/env ruby
# frozen_string_literal: true
#require 'dns_cacher'
require_relative '../lib/dns_cacher'
require 'async'

require 'optparse'
require 'etc'

ROOT = (Process.uid == 0)  # Flag if process is being run as root

CONFIG = {}
OptionParser.new do |opts|
  opts.banner = "Usage: dns_cacher [options]"

  opts.on("-D", "--[no-]daemon", "Run daemon (detached) mode, and log to Syslog") do |d|
    CONFIG[:daemon] = d
    CONFIG[:pidfile] = "/run/dns_cacher.pid"
  end

  opts.on("--debug", "Enable verbose debug output, and prevent backgrounding") do |d|
    CONFIG[:debug] = d
  end

  opts.on("--[no-]pidfile", "=[OPTIONAL]", "Write pid to file (implied by --daemon)") do |pidfile|
    # if true but no args, set to default pidfile
    CONFIG[:pidfile] = pidfile == true ? "/run/dns_cacher.pid" : pidfile
  end

  opts.on("-u", "--user", "=[OPTIONAL]", "Switch to specified user after setup (only makes sense if run as root)") do |user|
    CONFIG[:user] = user == true ? "nobody" : user
  end

  opts.on("-g", "--group", "=MANDATORY", "Switch to specifed group after setup (must be a permissible group, unless run as root)") do |group|
    CONFIG[:group] = group
  end

  opts.on_tail("--version", "Show version") do
    spec = Gem::Specification.find_by_name "dns_cacher"
    puts "#{spec.name} #{spec.version}"
    exit
  end

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end
end.parse! ARGV

# Detach process if we're to run as a daemon
Process.daemon if CONFIG[:daemon] and not CONFIG[:debug]

# Set up logging
# TODO: find a better way of logging, this is a mess
if CONFIG[:daemon]
  require 'syslog/logger'

  $logger = Syslog::Logger.new "dns_cacher", Syslog::LOG_DAEMON
  Syslog::Logger::syslog.mask = CONFIG[:debug] ? Syslog::LOG_UPTO(Syslog::LOG_DEBUG) : Syslog::LOG_UPTO(Syslog::LOG_INFO)

else
  require 'logger'

  $logger = Logger.new STDOUT
  $logger.level = CONFIG[:debug] ? Logger::DEBUG : Logger::INFO
end

# Setup pidfile if requested
if CONFIG[:pidfile]
  begin
    $pidfile = File.open(CONFIG[:pidfile], File::CREAT|File::EXCL|File::WRONLY, 0644)
    $pidfile.puts Process.pid
    $pidfile.flush

    # register hook to remove pidfile
    Kernel::at_exit do
      $pidfile.close
      File::delete($pidfile.path)
    end
  rescue Errno::EACCES
    $logger.error "No permission to write to PID file: #{CONFIG[:pidfile]}"
    exit!
  rescue Errno::ENOENT
    $logger.error "Failed to write to pidfile #{CONFIG[:pidfile]}"
    exit!
  end
end

# General warning about port permissions
unless ROOT
  $logger.warn "Not running as root, unable to bind local ports < 1000"
end

# default endpoints, should be overwritten by config
$DEFAULT_ENDPOINTS = [
  Addrinfo.udp("127.0.0.1", ROOT ? 53 : 1053),
  Addrinfo.udp("::1", ROOT ? 53 : 1053),
]

# Allow code from this point runs within an async reactor
Sync do |task|
  Signal.trap("INT") do |signo|
    if $logger.is_a? Syslog::Logger
      $logger.info "Signal #{Signal::signame(signo)} received!"
    else
      puts "Signal #{Signal::signame(signo)} received!"
    end

    task.reactor.interrupt
  end

  # Setup and run a BasicServer (name is a bit inaccurate, it does quite a bit)
  server = DNSCacher::BasicServer.new($DEFAULT_ENDPOINTS, $logger)

  # If requested drop privileges after setup
  if CONFIG[:user] or CONFIG[:group]
    begin
      # New user and gid
      # if USER isn't specified don't change (use current process uid)
      # if GROUP isn't specified use the default group for the specified USER
      new_user = CONFIG[:user] ? Etc.getpwnam(CONFIG[:user]) : Etc.getpwuid(Process.uid)
      new_group = CONFIG[:group] ? Etc.getgrnam(CONFIG[:group]) : Etc.getgrgid(new_user.gid)

      $logger.info "Switch privileges to #{new_user.name}:#{new_group.name}"

      $pidfile.chown(new_user.uid, new_group.gid) if CONFIG[:pidfile]
      Process.gid = new_group.gid
      Process.uid = new_user.uid
    rescue Errno::EPERM
      $logger.error "Insufficient permissions to switch user or group!"
    end
  end

  # run the server and await the main fiber
  $logger.info "Server setup complete"
  server.run.wait
ensure
  $logger.info "Server shut down"
end
