#!/bin/env ruby
# frozen_string_literal: true

require_relative '../lib/dns_cacher'
require 'async'

require 'optparse'
require 'etc'
require 'logger'
require 'syslog/logger'

ROOT = (Process.uid == 0)  # Flag if process is being run as root

$config = {}
OptionParser.new do |opts|
  opts.banner = "Usage: dns_cacher [options]"

  opts.on("-D", "--[no-]daemon", "Run daemon (detached) mode, and log to Syslog") do |d|
    $config[:daemon] = d
    $config[:pidfile] = "/run/dns_cacher.pid"
  end

  opts.on("--debug", "Enable verbose debug output, and prevent backgrounding") do |d|
    $config[:debug] = d
  end

  opts.on("--[no-]pidfile", "=[OPTIONAL]", "Write pid to file (implied by --daemon)") do |pidfile|
    # if true but no args, set to default pidfile
    $config[:pidfile] = pidfile == true ? "/run/dns_cacher.pid" : pidfile
  end

  opts.on("-u", "--user", "=[OPTIONAL]", "Switch to specified user after setup (only makes sense if run as root)") do |user|
    $config[:user] = user == true ? "nobody" : user
  end

  opts.on("-g", "--group", "=MANDATORY", "Switch to specifed group after setup (must be a permissible group, unless run as root)") do |group|
    $config[:group] = group
  end

  opts.on_tail("--version", "Show version") do
    spec = Gem::Specification.find_by_name "dns_cacher"
    puts "#{spec.name} #{spec.version}"
    exit
  end

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end
end.parse! ARGV

# Detach process if we're to run as a daemon
Process.daemon if $config[:daemon] and not $config[:debug]

# Set up logging
# TODO: find a better way of logging, this is a mess
if $config[:daemon]
  $logger = Syslog::Logger.new "dns_cacher", Syslog::LOG_DAEMON
  Syslog::Logger::syslog.mask = $config[:debug] ? Syslog::LOG_UPTO(Syslog::LOG_DEBUG) : Syslog::LOG_UPTO(Syslog::LOG_INFO)

else
  $logger = Logger.new STDOUT
  $logger.level = $config[:debug] ? Logger::DEBUG : Logger::INFO
end

# If resolvconf (openresolv) is present on the system, then  use it
if ROOT
  `which resolvconf`
  $config[:openresolv] = $?.success?

  if $config[:openresolv]
    # Create the interface
    r, w = IO.pipe
    spawn("resolvconf -a #{File.basename $0}", in: r, out: '/dev/null')
    r.close
    w.puts "# Generated by #{File.basename $0}"
    w.puts "nameserver 127.0.0.1"
    w.close
    $logger.info "Created openresolv interface"

    # exit hook to close the interface
    Kernel::at_exit do
      spawn("resolvconf -d #{File.basename $0}")
      Process.wait
      $logger.info "Removed openresolv interface"
    end
  end
end

# Setup pidfile if requested
if $config[:pidfile]
  begin
    $pidfile = File.open($config[:pidfile], File::CREAT|File::EXCL|File::WRONLY, 0644)
    $pidfile.puts Process.pid
    $pidfile.flush

    # register hook to remove pidfile
    Kernel::at_exit do
      $pidfile.close
      File::delete($pidfile.path)
    end
  rescue Errno::EACCES
    $logger.error "No permission to write to PID file: #{$config[:pidfile]}"
    exit!
  rescue Errno::ENOENT
    $logger.error "Failed to write to pidfile #{$config[:pidfile]}"
    exit!
  end
end

# General warning about port permissions
unless ROOT
  $logger.warn "Not running as root, unable to bind local ports < 1000"
end

# default endpoints, should be overwritten by config
$DEFAULT_ENDPOINTS = [
  Addrinfo.udp("127.0.0.1", ROOT ? 53 : 1053),
  Addrinfo.udp("::1", ROOT ? 53 : 1053),
]

# Allow code from this point runs within an async reactor
Sync do |task|
  Signal.trap("INT") do |signo|
    if $logger.is_a? Syslog::Logger
      $logger.info "Signal #{Signal::signame(signo)} received!"
    else
      puts "Signal #{Signal::signame(signo)} received!"
    end

    task.reactor.interrupt
  end
  
  # Figure out downstream nameservers
  nameservers = if $config[:openresolv]
    Resolver.parse_nameservers(`resolvconf -l`)
  else
    Resolver.parse_nameservers(File.read("/etc/resolv.conf"))
  end

  # Setup and run a BasicServer (name is a bit inaccurate, it does quite a bit)
  server = DNSCacher::BasicServer.new($DEFAULT_ENDPOINTS, nameservers: nameservers, logger: $logger)
  
  # Re-read system nameservers on SIGHUP
  Signal.trap("HUP") do |signo|
    unless task.reactor.closed?
      task.async do
        $logger.info "Reloading downstream DNS servers..."
        server.nameservers = if $config[:openresolv]
          Resolver.parse_nameservers(`resolvconf -l`)
        else
          Resolver.parse_nameservers(File.read("/etc/resolv.conf"))
        end
      end
    end
  end

  # If requested drop privileges after setup
  # WARN: only changes *effective* UID and GID, root is needed for pidfile and openresolv cleanup
  if $config[:user] or $config[:group]
    begin
      # New user and gid
      # if USER isn't specified don't change (use current process uid)
      # if GROUP isn't specified use the default group for the specified USER
      new_user = $config[:user] ? Etc.getpwnam($config[:user]) : Etc.getpwuid(Process.uid)
      new_group = $config[:group] ? Etc.getgrnam($config[:group]) : Etc.getgrgid(new_user.gid)

      $logger.info "Switch effective priviledges to #{new_user.name}:#{new_group.name}"

      $pidfile.chown(new_user.uid, new_group.gid) if $config[:pidfile]
      Process.egid = new_group.gid
      Process.euid = new_user.uid
    rescue Errno::EPERM
      $logger.error "Insufficient permissions to switch user or group!"
    end
  end

  # run the server and await the main fiber
  $logger.info "Server setup complete"
  server.run.wait
ensure
  # restore priviledges for clean up
  Process.euid = Process.uid if Process.uid == 0
  $logger.info "Server shut down"
end
